6.3 XSLT样式单的元素和指令 nn<xsl:apply-templates>元素qqselect属性nnxsl:apply-templates的作用就是指定继续遍历当前节点的所有子节点（以便根据实际路径和模板的match属性取值调用对应的模板），而select属性（取值为一个XPath表达式）允许指定仅遍历当前节点的哪些子节点（以调用相应的模板，如果存在）nn如果将(a)的模板1中的<xsl:apply-templates/>更改为<xsl:apply-templatesselect="message"/>，那么将仅调用message元素所对应的模板（而不会调用处理指令所对应的模板）。这样就可以根据具体的转换要求，仅遍历文档树中的部分内容 6.3 XSLT样式单的元素和指令 nn<xsl:apply-templates>元素qqmode属性可实现某个节点多次处理的需要nn当xsl:apply-templates有一个mode属性时，只有当match和mode两个属性值都有匹配值时，其模板才可实例化nnmode属性用于指定需要在match属性取值相同的模板中选择哪一个进行调用nn需要与xsl:template元素的mode属性配合使用 6.3 XSLT样式单的元素和指令 nn<xsl:apply-templates>元素qqmode属性可实现某个节点多次处理的需要 <Company><Name>Acme</Name><Person><Name>Dave</Name><Phone>123</Phone></Person></Company><xsl:templatematch="/"> 模板1 <xsl:apply-templates/></xsl:template><xsl:templatematch="Company"> 模板2 <xsl:apply-templatesselect="Name" mode="C"/><xsl:apply-templatesselect="Person/Name" mode="P"/></xsl:template><xsl:templatematch="Name"mode="C"> 模板3 ...Do sthfor Company Name...</xsl:template><xsl:templatematch="Name"mode="P"> 模板4 ...Do sthfor Person Name...</xsl:template>可以为模板3和模板4的match属性取不同的值6.3 XSLT样式单的元素和指令 nn<xsl:variable>和<xsl:param>元素qq定义变量和参数nn引用变量和参数使用$ nn参数可以从外部传递给转换程序，变量则在XSLT样式表内部定义nn变量赋值qq使用xsl:variable的select属性qq在xsl:variable元素的起始标签和结束标签之间定义qq全局变量（xsl:stylesheet的直接子元素）可在文档转换之前用程序赋值（转换器相关）<xsl:variablename=” variableName” select=” someExpression” /> <xsl:variablename=” variableName”> <!-- Some content goes here which can define the value of the variable. --> </xsl:variable> <xsl:paramname=”searchLetter” select=”’A’”/> 使用select给变量赋字符串值Ages.xml Ages.xsltAges.html6.3 XSLT样式单的元素和指令 nn命名模板和<xsl:call-template>元素qq命名模板由xsl:template元素的name属性标识qq调用命名模板使用xsl:call-template元素qqxsl:with-param元素用于在使用xsl:template声明模板时声明参数，也用于在xsl:call-template或者xsl:apply-templates中传递调用参数nnxsl:with-param的select属性可选，其值为表达式，表示如何选取需要传递的值<xsl:call-templatename=”TemplateName” />不带任何参数调用命名模板<xsl:templatename=”TemplateName”> <!-- The template content goes here. --> </xsl:template>6.3 XSLT样式单的元素和指令 nn命名模板和<xsl:call-template>元素<xsl:call-templatename=”TemplateName”> <xsl:with-paramname=”ParameterName” /> <!-- More <xsl:with-param> elements can go here. --> </xsl:call-template>要把一个参数传递给一个命名模板，该模板的定义格式（xsl:with-param）用来声明命名模板的参数<xsl:templatename=”TemplateName”> <xsl:with-paramname=”ParameterName” /> <!-- Rest of template goes here. --> </xsl:template>使用xsl:with-param传递一个或多个参数给命名模板6.3 XSLT样式单的元素和指令 nn模板参数的声明和传值qq在xsl:template元素开始标记和结束标记之间，使用xsl:param元素为所在的模板声明相应的模板参数qq在xsl:call-template元素的开始标记和结束标记之间，可以使用xsl:with-param元素为所调用的模板传递所需的参数 <xsl:templatename="doSth"><xsl:paramname="paramOne"/><xsl:paramname="paramTwo"/>...模板正文......使用"$paramOne" 和"$paramTwo" 引用两个模板参数... </xsl:template><xsl:call-templatename="doSth"><xsl:with-paramname="paramOne"select="'One'"/><xsl:with-paramname="paramTwo"select="."/> </xsl:call-template>使用xsl:with-param元素时必须指明具体的模板参数名称，以便为其进行赋值，所以可以不按照声明时的顺序书写可以使用xsl:with-param元素的as属性，为形式参数指定数据类型 6.3 XSLT样式单的元素和指令 nnXSLT中的内置模板qq内置模板（Built-in Templates）是XSLT中的一个关键内容，对于理解XSLT对XML文档树结构的遍历方式、模板调用机制等都是至关重要的qq通过一个具体的示例来说明内置模板的存在，并观察和解释各种内置模板的含义、以及处理对象 <xsl:stylesheetversion=“1.0"xmlns:xsl="http://www.w3.org/1999/XSL/Transform"><xsl:templatematch="*|/"> 模板1<xsl:apply-templates/></xsl:template><xsl:templatematch="text()|@*"> 模板2 <xsl:value-ofselect="."/></xsl:template><xsl:templatematch="processing-instruction()|comment()"/> 模板3



6.3 XSLT样式单的元素和指令 nn节点选择方式qq<xsl:template>的match属性用于指定要匹配的节点qq<xsl:copy-of>, <xsl:for-each>, <xsl:sort>, <xsl:apply-template>和<xsl:value-of>的select属性用于选择节点6.3 XSLT样式单的元素和指令 nn<xsl:copy>元素qq把一个节点复制到目标树，但不复制子孙节点qq如果上下文节点是一个元素节点，则不会复制节点的任何属性值nn使用某个元素并可改变其内容或增删属性<Persons> <Person /> <Person /> <Person /> </Person><?xml version=“1.0” encoding=“UTF-8”?> <Persons> <Person FirstName=“Jill” LastName=“Harper”/> <Person FirstName=“Claire” LastName=“Vogue”/> <Person FirstName=“Paul” LastName=“Cathedral”/> </Persons>只处理xsl:copy使用xsl:attribute增加属性Persons.xml Persons.xsltPersonsOut.xml Persons2.xslt6.3 XSLT样式单的元素和指令 nn<xsl:copy-of>元素qq深度复制，把一个节点及其所有属性节点和子孙节点都复制到目标树xsl:copyxsl:copy-of功能将当前节点从源文档复制到目标树复制任何节点集到目标树对当前节点的处理仅复制当前节点，不复制其子元素或者属性复制节点及其所有的子孙节点，包括属性和子元素节点内容可以使用XSLT代码为新的节点创建内容，如果当前节点是元素节点或者根节点所有的内容都来自select属性中指定的节点集PurchaseOrder.xml PurchaseOrder.xsltInvoice.xml6.3 XSLT样式单的元素和指令 nn<xsl:output>元素qq使用method属性从XML, HTML或文本文档中选择一种输出格式nnmethod属性的值大小写敏感，并且必须小写（xml, html, text）<xsl:output method=“output type” />6.3 XSLT样式单的元素和指令 nn<xsl:if>元素qq测试一个布尔条件nn为真则实例化<xsl:if>元素的内容nn为假则<xsl:if>元素的内容不会被添加到目标树nn输出一些内容或没有任何输出<Characters> <Character age=“99”>Julius Caesar</Character> <Character age=“23”>Anne Boleyn</Character> <Character age=“41”>George Washington</Character> <Character age=“45”>Martin Luther</Character> <Character age=“800”>Methuselah</Character> <Character age=“119”>Moses</Character> <Character age=“50”>Asterixthe Gaul</Character> </Characters> <xsl:templatematch=“Character”> <xsl:iftest=“@age > 110 ” > <p><b><xsl:value-ofselect=“.” /></b> is older than expected. Please check if this character’s age, <b><xsl:value-ofselect=“@age” /></b>, is correct.</p> </xsl:if> </xsl:template> test属性返回false时，Character元素的模板不输出任何内容Characters.xml Characters.xslt6.3 XSLT样式单的元素和指令 nn<xsl:choose>元素qq多个选项中选取一个nnxsl:choose可以有任意个xsl:when元素作为其子元素，每一个都有一个test属性进行逻辑判断 nn如果xsl:when元素内容均未输出，则输出xsl:otherwise元素内容<xsl:templatematch=“Character”> <xsl:choose> <xsl:whentest=“@age > 110” > <p><b><xsl:value-ofselect=“.” /></b> - too high. Please check if this character’s age, <b><xsl:value-ofselect=“@age” /></b>, is correct.</p> </xsl:when> <xsl:otherwise> <p><b><xsl:value-ofselect=“.” /></b> - ok</p>. </xsl:otherwise> </xsl:choose> </xsl:template>

ate�Pc��



6.3 XSLT样式单的元素和指令 nn<xsl:for-each>元素qq把嵌入其中的XSLT指令作用到节点集的每个元素qq可迭代处理整个节点集，并为节点集中每个节点生成输出文档nn理论上处理器可按任意顺序处理节点集中的节点<xsl:templatematch=“Object”> <ul> <xsl:for-eachselect=”Characteristic”> <li><xsl:value-ofselect=”.” /></li> </xsl:for-each> </ul> </xsl:template> 用LRE表示无序列表的起始标签和结束标签（<ul>和</ul>），上下文节点是Object元素节点，xsl:for-each为上下文节点的每个子节点生成一个列表项，列表项对应于上下文节点的每个Characteristic元素Objects.xml Objects.xslt6.3 XSLT样式单的元素和指令 nn<xsl:sort>元素qq可对节点集中的元素排序，可多次使用nn元素在输出中的顺序可完全不同于节点在源文档中的顺序qq可与xsl:apply-templates和xsl:for-each一起使用<xsl:apply-templatesselect=”/Objects/Object” > <xsl:sortselect=”@name” /> </xsl:apply-templates> xsl:sort的select属性值是一个相对定位路径@name，是Object的子节点name属性节点<xsl:templatematch=”Object”> <h3>Characteristics of <xsl:value-ofselect=”@name” /></h3> <ul> <xsl:for-eachselect=”Characteristic”> <xsl:sortselect=”.” order=”descending” /> <li><xsl:value-ofselect=”.” /></li> </xsl:for-each> </ul> </xsl:template> xsl:sort的order属性来说明排序模式，默认排序为升序ObjectsSort.xml ObjectsSort.xslt6.3 XSLT样式单的元素和指令 nn<xsl:include>和<xsl:import>元素qq都是xsl:stylesheet的直接子元素qqxsl:include将外部的样式单复制到该元素所在位置，一个样式单只能被包含一次，被包含样式单的模板规则与包含者规则优先级相同<xsl:stylesheetversion="1.0"xmlns:xsl="..."><xsl:includehref="Utility.xsl"/> <xsl:includehref="Tools.xsl"/></xsl:stylesheet><xsl:stylesheetversion="1.0"xmlns:xsl="..."><xsl:importhref="Utility.xsl"/> <xsl:importhref="Tools.xsl"/> <xsl:templatematch="node"> <xsl:apply-imports/> ...</xsl:stylesheet>6.3 XSLT样式单的元素和指令 nnxsl:import和xsl:include的区别nnimport与include必须为顶层元素，如果import与include同时存在，那么import在include之前声明 nninclude与原样式表中的模板处于完全相同的地位（具有相同的默认优先级）,没有任何差别，但是import导入的模板则具有较低的默认优先级nnimportadds components from another schema with a different namespace nnincludeassociates with the target namespace 6.4 XSLT函数 nndocument()可访问上下文节点所在的文档以及其他文档qq可使用多个XML文档作为源文档nnkey()与xsl:key一起使用，为XML源文档提供索引机制nnformat-number()与xsl:decimal-format元素一起使用，可以精确控制保存到目标文档的数值格式nngenerate-id()在目标树中生成ID属性节点6.5 XSLT2.0nnwww.w3.org/tr/xslt20/ nn使用XPath2.0和Xquery的数据模型nnW3C XML Schema数据类型代替了XPath1.0和XSLT1.0的数据类型nn新增部分元素，可实现分组功能nn可转换非良构XML文本数据nn改进了文本解析指令nn可把输出结果保存在多个文档nn新增了专用函数，也可自定义函数

2;, is~P���







